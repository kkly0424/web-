### 1.作用域嵌套

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达到最外层（全局作用域）为止。

##### RHS和LHS查询

作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用LHS查询；如果目的是获取变量的值，就会使用RHS查询。

如果RHS查询在所有的嵌套的作用域中都寻不到所需的变量，引擎就会抛出**ReferenceError**异常，通常表现为 b is not defined。

当引擎执行LHS查询时，如果同样到全局作用域也无法找到目标变量，**全局作用域中就会自己创建一个具有该名称的变量，并将其返回给引擎，前提是程序运行在非 严格模式 下。**严格模式禁止自动或隐式的创建全局变量。因此在严格模式下LHS查询未成功找到该变量同样会抛出**ReferenceError**异常。

ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。



### 2.词法阶段

词法作用域就是定义在词法阶段的作用域，**编写代码时，变量和代码块写在什么位置，决定了词法分析阶段乃至运行时的作用域**，前提是没有使用with语句和eval方法。**无论函数在哪里被调用，或如何被调用，它的词法作用域都只是由函数被声明时所处的位置决定**。

全局变量会自动成为全局对象的属性（如浏览器中的window对象），因此可以间接地通过对全局对象属性的引用来对其进行访问

#### **遮蔽效应**

作用域查找会在找到第一个匹配的标识符时停止，在多层嵌套作用域中，可以定义同名的标识符，这叫做“遮蔽效应”，即内部的标识符遮蔽了外部的标识符，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行。

#### 欺骗词法

欺骗词法作用域会导致性能下降。

#### eval：

##### eval方法参数接收js代码字符串，在使用时，该字符串会被自动解析成当前位置的一个js语句并执行。

在非严格模式下，eval会在运行期间修改书写期间的词法作用域；在严格模式下则拥有自己的词法作用域。

缺陷：eval比直接运行要慢很多，主要花费在代码编译上，使用eval，内存会消耗很多，导致内存浪费。

#### **with：**

with通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。

```JavaScript
var obj = {a: 1,b: 2,c: 3};
// 单调乏味的重复"obj"
obj.a = 2;obj.b = 3;obj.c = 4;
// 简单的快捷方式
with (obj) 
{a = 3;b = 4;c = 5;}
```

with语句中的赋值语句，会对属性进行LHS操作，会沿着作用域链往上查找，**在非严格模式下，不成功的LHS引用会导致自动隐式地创建一个全局变量，这样的变量归全局window**。这就会导致私有变量暴露到全局中。



### 3.函数作用域和块作用域

#### 函数作用域

函数作用域是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用，**在块级作用域中使用var声明变量时，该变量最终都会属于外部作用域（即var会突破除函数作用域块外的块级作用域）。而对于函数作用域的话，var声明的变量只属于当前函数作用域**

函数声明和函数表达式：函数声明会提升到整个函数顶部，在声明的代码前也可以调用；函数表达式是提升变量，等到定义处才将函数赋值给变量，所以在函数表达式书写位置前调用函数会提示undefined。

#### try/catch: 

try/catch的catch分局会创建一个块作用域，其中声明的变量仅在catch内部有效

#### let：

ES6以后，提供了let和const的声明变量方式，使块级作用域内部声明的变量不会污染全局（即let声明的变量不会被提升到全局，而是会被绑定到当前作用域块）；而在函数作用域内，无论是var、let、const声明变量，外部都是不可访问的。

#### const：

const常量关键字，声明后任何修改值的操作都会引起错误，但声明数组和对象后可对内部属性进行修改且不会报错。作用域与let相同。

#### 隐藏内部实现

本质上将一些函数和变量封装在一个包装函数内，使得外部无法直接使用里面的变量或函数。这样既**规避了冲突，防止被覆盖，也坚持着最小暴露原则**，将没必要暴露的写到函数作用域里。一个函数想要完全私有化，就把变量和方法都写在内部，外部只能调用，无法影响函数内部。

***最小权限原则**（PoLP)是一种信息安全概念，即为用户提供执行其职责所需要的最小权限等级或许可。最小权限原则被广泛认为是网络安全的最佳实践，也是保护高价值数据和资产的特权访问的基本方式。*

***API设计**，API对于用户来说是一个黑匣子，开发人员可以很方便的修改内部实现逻辑，而不会影响到用户使用。*

#### 垃圾收集

JavaScript自动回收不再使用的变量,释放其所占的内存,开发人员不需要手动的做垃圾回收的处理，**垃圾回收机制只会回收局部变量。**

**全局变量并不会被回收(全局变量在浏览器关闭之后会回收)**,所有当我们定义了一个全局对象时,使用完毕之后,最好给它重新复制为null,以便释放其所占的内存(这个变量并没有被回收,只是改变了他的志向,减少内存占用)。

目前浏览器基本都使用标记清除(介绍....)的方式,还有一种不常见的引用计数(介绍...)方式。



### 4.提升

JavaScript代码在执行前都会先编译一部分，主要是声明部分。所以在执行的时候，其实变量声明过了，剩下的就是赋值。

变量提升只对var声明的变量有效。

**变量提升：**变量提升，是在当前气泡（作用域中提升），而不是提升到全局。

**函数提升：**函数声明会被提升；而函数表达式中声明部分会被提升，赋值部分不提升，此时在该表达式前调用该函数则会报TypeError。

***暂时性死区：***ES6规定，let/const 命令会使区块形成封闭的[作用域](https://so.csdn.net/so/search?q=作用域&spm=1001.2101.3001.7020)。若在声明之前使用变量，就会报错。总之，**在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。**这在语法上，称为 “暂时性死区”（ temporal dead zone，简称 TDZ）

```javascript
var a = 123;
if (true) {
  // 变量a的暂时性死区开始
  console.log(a); // ReferenceError: Cannot access 'a' before initialization
  let a; 
  // 变量a的暂时性死区开始
  console.log(a); // undefined
  a = 123;
  console.log(a); // 123
}
```

**函数优先：**代码在编译时，会先查找函数声明，再查找变量声明，如果变量声明和函数声明同名，则会忽略变量声明。但是后面的同名函数声明会覆盖前面的函数声明。

ES6引入了块级作用域，明确允许在块级作用域中声明函数。ES6规定，**块级作用域之中**，严格模式下，函数声明只会被提升到代码块顶部，块级外不可引用；非严格模式下，则会被提升到全局作用域中。

### 5.闭包

**理解**：闭包可以理解为在当前函数内部定义另一个函数，该函数除了拥有自身的作用域外，还保持对外部作用域的引用，并且自身作为返回值返回。然后在其它作用域调用该函数时，就可以访问到对外部作用域的引用的数据。（闭包是一把打开内部作用域的钥匙，让父作用域能够访问到子作用域）

**本质：**本质就是一个函数被当作一个值传递后，脱离了原来的作用域，在新的作用域被引用后依然保持着以前的作用域的访问能力。

```javascript
		function A(){
            let a = 10;
            function B(){
                console.log(a);
            }
            return B //需要将B方法暴露出去
        }
        A()() //10 外部能获取到A作用域内的变量a
        function C(){
            A()() //C作用域内也可以获取到A作用域内的变量a
        }
        C() //10
```

**闭包的三种类型：**函数作为返回值被传递；函数作为参数被传递；间接将函数传递给全局变量。

**内存泄露：**闭包始终存在对其原词法作用域的引用，使得原来的函数体不会被销毁。

#### 模块

**模块暴露：**将有共同联系的数据和方法封装到一个函数中，通过return返回对函数中方法的引用。

**模块模式需要具备的两个必要条件：**

​	1.必须有外部的封装函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）；

​	2.封装函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或修改私有的状态。

**单例模式：**......

